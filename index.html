<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Forest Fire Model (Drossel–Schwabl)</title>
  <style>
    :root{
      --bg:#ffffff;
      --panel:#f6f6f6;
      --border:#d9d9d9;
      --text:#111;
      --muted:#666;
      --shadow: 0 1px 0 rgba(0,0,0,.04), 0 6px 24px rgba(0,0,0,.06);
      font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, system-ui, sans-serif;
      color: var(--text);
    }
    body{ margin:0; background:var(--bg); }
    .wrap{ max-width: 1180px; margin: 0 auto; padding: 22px 18px 40px; }
    h1{ font-size: 28px; font-weight: 700; margin: 0 0 14px; letter-spacing:.2px; }
    h2{ font-size: 16px; margin: 18px 0 8px; font-weight: 700; }
    .grid{
      display:grid;
      grid-template-columns: 380px 1fr;
      gap: 16px;
      align-items:start;
    }
    .panel{
      background: var(--panel);
      border: 1px solid var(--border);
      border-radius: 10px;
      padding: 14px;
      box-shadow: var(--shadow);
    }
    .row{ margin: 10px 0; }
    label{ display:flex; justify-content:space-between; gap:10px; font-size: 13px; }
    input[type="range"]{ width:100%; }
    input[type="number"]{
      width: 100%;
      box-sizing: border-box;
      padding: 8px 10px;
      border-radius: 8px;
      border: 1px solid var(--border);
      background:#fff;
      font-size: 14px;
    }
    .mono{ font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace; }
    .muted{ color:var(--muted); font-size:12px; line-height:1.35; }
    .btns{ display:flex; gap:10px; flex-wrap:wrap; margin-top: 10px; }
    button{
      padding: 8px 12px;
      border-radius: 10px;
      border: 1px solid var(--border);
      background:#fff;
      cursor:pointer;
      font-size: 13px;
    }
    button:hover{ filter: brightness(.98); }
    button:disabled{ opacity:.6; cursor:not-allowed; }

    .simCard{
      background: var(--panel);
      border: 1px solid var(--border);
      border-radius: 10px;
      padding: 14px;
      box-shadow: var(--shadow);
      overflow: hidden;
    }
    .simTop{
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap: 12px;
      margin-bottom: 10px;
      flex-wrap: wrap;
    }
    .simArea{
      display:grid;
      place-items:center;
      background:#fff;
      border: 1px solid var(--border);
      border-radius: 10px;
      padding: 10px;
      overflow:auto;
    }
    canvas#sim{
      image-rendering: pixelated;
      border: 1px solid #333;
      background:#000;
      display:block;
      cursor: crosshair;
    }
    .stats{
      margin-top: 10px;
      padding-top: 10px;
      border-top: 1px solid var(--border);
      font-size: 13px;
      line-height: 1.65;
    }
    .plots{
      margin-top: 16px;
      display:grid;
      grid-template-columns: 1fr 1fr;
      gap: 16px;
    }
    .plotTitleRow{
      display:flex; justify-content:space-between; align-items:center; gap:10px; flex-wrap:wrap;
      margin-bottom: 8px;
    }
    .plot{
      width: 100%;
      height: 260px;
      border: 1px solid var(--border);
      border-radius: 10px;
      background:#fff;
    }
    .legendRow{
      display:flex;
      gap: 14px;
      align-items:center;
      font-size: 12px;
      color: var(--muted);
      margin-top: 6px;
      flex-wrap: wrap;
    }
    .swatch{ width: 10px; height: 10px; display:inline-block; border-radius: 2px; margin-right: 6px; }
    hr{ border:0; border-top:1px solid var(--border); margin: 14px 0; }
    @media (max-width: 980px){
      .grid{ grid-template-columns: 1fr; }
      .plots{ grid-template-columns: 1fr; }
    }
  </style>
</head>
<body>
<div class="wrap">
  <h1>Forest Fire Model (Drossel–Schwabl)</h1>

  <div class="grid">
    <!-- Controls + Stats -->
    <div class="panel">
      <div class="row">
        <label>
          <span>Tree Growth Probability (p):</span>
          <span class="mono" id="pVal">0.0100</span>
        </label>
        <input id="p" type="range" min="0" max="0.05" step="0.0001" value="0.01">
      </div>

      <div class="row">
        <label>
          <span>Lightning Strike Probability (f):</span>
          <span class="mono" id="fVal">1.00e-5</span>
        </label>
        <input id="f" type="range" min="0" max="0.001" step="0.000001" value="0.00001">
      </div>

      <div class="row">
        <label>
          <span>Steps per Frame (Growth):</span>
          <span class="mono" id="spfVal">1000</span>
        </label>
        <input id="spf" type="range" min="1" max="20000" step="1" value="1000">
        <div class="muted">Two-timescale mode: growth runs until a fire starts; then growth pauses while the fire spreads step-by-step.</div>
      </div>

      <div class="row">
        <label><span>Seed:</span></label>
        <input id="seed" class="mono" type="number" value="42">
      </div>

      <div class="row">
        <label>
          <span>Animate Fires (Pretty, but SLOW data)</span>
          <input id="animate" type="checkbox" checked>
        </label>
        <div class="muted">If unchecked, fires advance faster (more fire-steps per frame).</div>
      </div>

      <hr />

      <h2>Prescribed Fire</h2>

      <div class="row">
        <label>
          <span>Prescribed Fire Size (ignition cells):</span>
          <span class="mono" id="pfSizeVal">300</span>
        </label>
        <input id="pfSize" type="range" min="1" max="12000" step="1" value="300">
        <div class="muted">Ignites exactly this many trees (if enough trees exist inside the unit).</div>
      </div>

      <div class="row">
        <label>
          <span>Fire Steps per Frame:</span>
          <span class="mono" id="fireSpfVal">1</span>
        </label>
        <input id="fireSpf" type="range" min="1" max="80" step="1" value="1">
      </div>

      <div class="row">
        <label>
          <span>Use Containment Boundary</span>
          <input id="containOn" type="checkbox" checked>
        </label>
        <div class="muted">Applies ONLY to prescribed fires (not lightning). If a drawn polygon exists, it acts as the boundary.</div>
      </div>

      <div class="row">
        <label>
          <span>Boundary Radius (cells):</span>
          <span class="mono" id="containRVal">60</span>
        </label>
        <input id="containR" type="range" min="1" max="350" step="1" value="60">
        <div class="muted">Used only if you have NOT drawn a polygon unit.</div>
      </div>

      <hr />

      <h2>Burn Unit Polygon</h2>
      <div class="muted" style="margin-bottom:8px;">
        Click on the map to add vertices. Double-click (or press Enter) to finish.
      </div>

      <div class="row">
        <label>
          <span>Use Polygon for Prescribed Fire</span>
          <input id="usePoly" type="checkbox" checked>
        </label>
      </div>

      <div class="btns">
        <button id="drawPolyBtn">Draw Unit</button>
        <button id="finishPolyBtn" disabled>Finish Unit</button>
        <button id="clearPolyBtn" disabled>Clear Unit</button>
      </div>
      <div class="muted">Unit vertices: <span class="mono" id="polyCount">0</span> • Status: <span class="mono" id="polyStatus">none</span></div>

      <hr />

      <div class="btns">
        <button id="igniteBtn">Start Prescribed Fire</button>
        <button id="startBtn">Start</button>
        <button id="resetBtn">Reset</button>
      </div>

      <h2>Live Statistics</h2>
      <div class="stats">
        <div>Timesteps (<span class="mono">N<sub>s</sub></span>): <span class="mono" id="ns">0</span></div>
        <div>Tree Count: <span class="mono" id="trees">0</span></div>
        <div>Tree Density (<span class="mono">&rho;</span>): <span class="mono" id="rho">0.00%</span></div>
        <div>Total Fires: <span class="mono" id="fires">0</span></div>
      </div>
    </div>

    <!-- Simulation -->
    <div class="simCard">
      <div class="simTop">
        <div class="row" style="margin:0; min-width: 260px;">
          <label style="margin-bottom:6px;">
            <span>Zoom:</span>
            <span class="mono" id="zoomVal">100%</span>
          </label>
          <input id="zoom" type="range" min="50" max="220" step="1" value="100">
        </div>
        <p class="muted" style="margin:0;">Grid: <span class="mono">512 × 512</span> (zoom is CSS scaling)</p>
      </div>

      <div class="simArea">
        <canvas id="sim" width="512" height="512"></canvas>
      </div>

      <div class="legendRow">
        <span><span class="swatch" style="background:#00b400"></span>Tree</span>
        <span><span class="swatch" style="background:#ff5a00"></span>Burning</span>
        <span><span class="swatch" style="background:#000"></span>Empty</span>
        <span><span class="swatch" style="background:rgba(0,180,255,.9)"></span>Burn Unit Polygon</span>
      </div>
    </div>
  </div>

  <!-- Plots -->
  <div class="plots">
    <div class="panel">
      <div class="plotTitleRow">
        <h2 style="margin:0;">Tree Density Over Time (points)</h2>
        <span class="muted">last 900 frames</span>
      </div>
      <canvas id="rhoPlot" class="plot" width="560" height="260"></canvas>
    </div>

    <div class="panel">
      <div class="plotTitleRow">
        <h2 style="margin:0;">Fire Size Distribution (points, log-log)</h2>
        <label style="gap:10px; align-items:center;">
          <span class="muted">Use Logarithmic Binning</span>
          <input id="logBin" type="checkbox" checked>
        </label>
      </div>
      <canvas id="firePlot" class="plot" width="560" height="260"></canvas>
      <div class="legendRow">
        <span><span class="swatch" style="background:#0a58ca"></span>Lightning (smaller points)</span>
        <span><span class="swatch" style="background:#c92a2a"></span>Prescribed (larger points)</span>
      </div>
    </div>
  </div>
</div>

<script>
/** Seeded RNG (Mulberry32) */
function mulberry32(seed) {
  let t = seed >>> 0;
  return function() {
    t += 0x6D2B79F5;
    let x = Math.imul(t ^ (t >>> 15), 1 | t);
    x ^= x + Math.imul(x ^ (x >>> 7), 61 | x);
    return ((x ^ (x >>> 14)) >>> 0) / 4294967296;
  };
}

const sim = document.getElementById("sim");
const sctx = sim.getContext("2d", { alpha: false });

const W = sim.width, H = sim.height, N = W * H;

// 0 empty, 1 tree, 2 burning
let grid = new Uint8Array(N);

// UI
const pEl = document.getElementById("p");
const fEl = document.getElementById("f");
const spfEl = document.getElementById("spf");
const seedEl = document.getElementById("seed");
const animateEl = document.getElementById("animate");
const zoomEl = document.getElementById("zoom");

const pfSizeEl = document.getElementById("pfSize");
const fireSpfEl = document.getElementById("fireSpf");
const containOnEl = document.getElementById("containOn");
const containREl = document.getElementById("containR");
const usePolyEl = document.getElementById("usePoly");
const logBinEl = document.getElementById("logBin");

const drawPolyBtn = document.getElementById("drawPolyBtn");
const finishPolyBtn = document.getElementById("finishPolyBtn");
const clearPolyBtn = document.getElementById("clearPolyBtn");
const polyCountEl = document.getElementById("polyCount");
const polyStatusEl = document.getElementById("polyStatus");

const pVal = document.getElementById("pVal");
const fVal = document.getElementById("fVal");
const spfVal = document.getElementById("spfVal");
const pfSizeVal = document.getElementById("pfSizeVal");
const fireSpfVal = document.getElementById("fireSpfVal");
const containRVal = document.getElementById("containRVal");
const zoomVal = document.getElementById("zoomVal");

const igniteBtn = document.getElementById("igniteBtn");
const startBtn = document.getElementById("startBtn");
const resetBtn = document.getElementById("resetBtn");

const nsEl = document.getElementById("ns");
const treesEl = document.getElementById("trees");
const rhoEl = document.getElementById("rho");
const firesEl = document.getElementById("fires");

// Plots
const rhoPlot = document.getElementById("rhoPlot");
const rctx = rhoPlot.getContext("2d", { alpha: false });
const firePlot = document.getElementById("firePlot");
const fctx = firePlot.getContext("2d", { alpha: false });

// labels
function fmtSci(x) { return x === 0 ? "0" : x.toExponential(2); }

function syncLabels() {
  pVal.textContent = (+pEl.value).toFixed(4);
  fVal.textContent = fmtSci(+fEl.value);
  spfVal.textContent = String(+spfEl.value);
  pfSizeVal.textContent = String(+pfSizeEl.value);
  fireSpfVal.textContent = String(+fireSpfEl.value);
  containRVal.textContent = String(+containREl.value);
  zoomVal.textContent = `${+zoomEl.value}%`;
}
[pEl, fEl, spfEl, pfSizeEl, fireSpfEl, containREl, zoomEl].forEach(el => el.addEventListener("input", syncLabels));
syncLabels();

// zoom (CSS scaling)
function applyZoom() {
  const pct = +zoomEl.value;
  sim.style.width = (W * pct / 100) + "px";
  sim.style.height = (H * pct / 100) + "px";
}
zoomEl.addEventListener("input", applyZoom);
applyZoom();

// Stats
let rng = mulberry32(42);
let running = false;

let Ns = 0;
let treeCount = 0;
let fireCount = 0;

// Plot data
const rhoSeries = [];
const rhoMaxPoints = 900;

const fireSizesLightning = [];
const fireSizesPrescribed = [];
const fireMaxKeep = 30000;

// Rendering (fast pixel blit)
const img = sctx.createImageData(W, H);
const pix = img.data;

/** ---------- Polygon drawing (burn unit) ---------- */
let drawMode = false;              // actively drawing (adding vertices)
let polyDraft = [];                // vertices while drawing: [{x,y},...]
let polyFinal = null;              // final polygon vertices
let polyMask = null;               // Uint8Array mask for inside polygon (1=inside)
let polyIndices = null;            // array of indices inside polygon (cached)

function updatePolyUI() {
  const count = drawMode ? polyDraft.length : (polyFinal ? polyFinal.length : 0);
  polyCountEl.textContent = String(count);
  polyStatusEl.textContent = drawMode ? "drawing" : (polyFinal ? "ready" : "none");
  finishPolyBtn.disabled = !(drawMode && polyDraft.length >= 3);
  clearPolyBtn.disabled = !(polyFinal || polyDraft.length > 0);
  drawPolyBtn.textContent = drawMode ? "Stop Drawing" : "Draw Unit";
}

function canvasToCell(evt) {
  const rect = sim.getBoundingClientRect();
  const sx = (evt.clientX - rect.left) / rect.width;
  const sy = (evt.clientY - rect.top) / rect.height;
  const x = Math.max(0, Math.min(W - 1, Math.floor(sx * W)));
  const y = Math.max(0, Math.min(H - 1, Math.floor(sy * H)));
  return { x, y };
}

function pointInPoly(px, py, verts) {
  // ray casting; px/py are floats (cell centers), verts are {x,y} (ints)
  let inside = false;
  for (let i = 0, j = verts.length - 1; i < verts.length; j = i++) {
    const xi = verts[i].x, yi = verts[i].y;
    const xj = verts[j].x, yj = verts[j].y;
    const intersect = ((yi > py) !== (yj > py)) &&
      (px < (xj - xi) * (py - yi) / ((yj - yi) || 1e-9) + xi);
    if (intersect) inside = !inside;
  }
  return inside;
}

function buildPolyMask(verts) {
  const mask = new Uint8Array(N);
  const indices = [];
  // brute force: check each cell center; done only when finishing polygon
  for (let y = 0; y < H; y++) {
    const py = y + 0.5;
    for (let x = 0; x < W; x++) {
      const px = x + 0.5;
      if (pointInPoly(px, py, verts)) {
        const i = y * W + x;
        mask[i] = 1;
        indices.push(i);
      }
    }
  }
  polyMask = mask;
  polyIndices = indices;
}

function startDrawing() {
  drawMode = true;
  polyDraft = [];
  polyFinal = null;
  polyMask = null;
  polyIndices = null;
  updatePolyUI();
  renderSim(); // show blank overlay state
}

function stopDrawing() {
  drawMode = false;
  polyDraft = [];
  updatePolyUI();
  renderSim();
}

function finishPolygon() {
  if (!drawMode || polyDraft.length < 3) return;
  drawMode = false;
  polyFinal = polyDraft.slice();
  polyDraft = [];
  buildPolyMask(polyFinal);
  updatePolyUI();
  renderSim();
}

function clearPolygon() {
  drawMode = false;
  polyDraft = [];
  polyFinal = null;
  polyMask = null;
  polyIndices = null;
  updatePolyUI();
  renderSim();
}

drawPolyBtn.addEventListener("click", () => {
  if (drawMode) stopDrawing();
  else startDrawing();
});

finishPolyBtn.addEventListener("click", finishPolygon);
clearPolyBtn.addEventListener("click", clearPolygon);

// Canvas clicks add vertices when drawing
sim.addEventListener("click", (evt) => {
  if (!drawMode) return;
  const { x, y } = canvasToCell(evt);
  polyDraft.push({ x, y });
  updatePolyUI();
  renderSim();
});

// Double click finishes
sim.addEventListener("dblclick", (evt) => {
  if (!drawMode) return;
  evt.preventDefault();
  finishPolygon();
});

// Keyboard shortcuts
window.addEventListener("keydown", (evt) => {
  if (!drawMode) return;
  if (evt.key === "Enter") {
    finishPolygon();
  } else if (evt.key === "Backspace") {
    evt.preventDefault();
    polyDraft.pop();
    updatePolyUI();
    renderSim();
  } else if (evt.key === "Escape") {
    stopDrawing();
  }
});

updatePolyUI();

/** ---------- Render sim + overlays ---------- */
function drawPolygonOverlay(verts, isDraft) {
  if (!verts || verts.length === 0) return;

  sctx.save();
  // Make overlay visible on both black/green/orange
  sctx.strokeStyle = "rgba(0,180,255,0.95)";
  sctx.fillStyle = isDraft ? "rgba(0,180,255,0.10)" : "rgba(0,180,255,0.08)";
  sctx.lineWidth = 1.5;

  sctx.beginPath();
  sctx.moveTo(verts[0].x + 0.5, verts[0].y + 0.5);
  for (let i = 1; i < verts.length; i++) {
    sctx.lineTo(verts[i].x + 0.5, verts[i].y + 0.5);
  }
  if (!isDraft) sctx.closePath();
  sctx.stroke();

  if (!isDraft) {
    sctx.fill();
  } else if (verts.length >= 3) {
    // show faint fill even while drawing once 3+ points exist
    sctx.save();
    sctx.globalAlpha = 0.12;
    sctx.closePath();
    sctx.fill();
    sctx.restore();
  }

  // draw vertex points
  sctx.fillStyle = "rgba(0,180,255,0.95)";
  for (const v of verts) {
    sctx.beginPath();
    sctx.arc(v.x + 0.5, v.y + 0.5, 2.2, 0, Math.PI * 2);
    sctx.fill();
  }
  sctx.restore();
}

function renderSim() {
  // raster layer
  for (let i = 0; i < N; i++) {
    const s = grid[i];
    const o = i * 4;
    if (s === 0) { pix[o]=0; pix[o+1]=0; pix[o+2]=0; pix[o+3]=255; }
    else if (s === 1) { pix[o]=0; pix[o+1]=180; pix[o+2]=0; pix[o+3]=255; }
    else { pix[o]=255; pix[o+1]=90; pix[o+2]=0; pix[o+3]=255; }
  }
  sctx.putImageData(img, 0, 0);

  // overlays
  if (polyFinal) drawPolygonOverlay(polyFinal, false);
  if (drawMode && polyDraft.length) drawPolygonOverlay(polyDraft, true);
}

function updateStatsUI() {
  nsEl.textContent = String(Ns);
  treesEl.textContent = String(treeCount);
  rhoEl.textContent = (100 * treeCount / N).toFixed(2) + "%";
  firesEl.textContent = String(fireCount);
}

// Neighbors (von Neumann)
function neighbors(i) {
  const x = i % W, y = (i / W) | 0;
  return [
    (x > 0)     ? i - 1 : -1,
    (x < W - 1) ? i + 1 : -1,
    (y > 0)     ? i - W : -1,
    (y < H - 1) ? i + W : -1,
  ];
}

/** ---------- Fire state (two-timescale: pause growth during fire) ---------- */
let fireActive = false;
let burningNow = [];
let currentFireSize = 0;
let currentFireType = "lightning"; // "lightning" | "prescribed"

// containment (ONLY used for prescribed + containOn)
let boundaryOn = false;
let boundaryMode = "none"; // "none" | "circle" | "polygon"
let boundaryCx = 0, boundaryCy = 0, boundaryR = 0;

function insideBoundaryIndex(i) {
  if (!boundaryOn) return true;
  if (boundaryMode === "polygon") {
    return polyMask ? (polyMask[i] === 1) : true;
  }
  // circle
  const x = i % W, y = (i / W) | 0;
  const dx = x - boundaryCx;
  const dy = y - boundaryCy;
  return (dx*dx + dy*dy) <= boundaryR*boundaryR;
}

function startFire(initialBurningIndices, type, centerX, centerY) {
  if (initialBurningIndices.length === 0) return;

  fireActive = true;
  fireCount++;
  currentFireSize = 0;
  currentFireType = type;

  // boundary ONLY for prescribed fires
  if (type === "prescribed" && containOnEl.checked) {
    // If polygon exists and user wants polygon, use it as boundary
    if (usePolyEl.checked && polyFinal && polyMask) {
      boundaryOn = true;
      boundaryMode = "polygon";
    } else {
      boundaryOn = true;
      boundaryMode = "circle";
      boundaryCx = centerX;
      boundaryCy = centerY;
      boundaryR  = +containREl.value;
    }
  } else {
    boundaryOn = false;
    boundaryMode = "none";
  }

  // if circle boundary chosen, set center anyway
  boundaryCx = centerX;
  boundaryCy = centerY;

  burningNow = [];

  for (const i of initialBurningIndices) {
    if (grid[i] === 1 && insideBoundaryIndex(i)) {
      grid[i] = 2; // tree -> burning
      burningNow.push(i);
      treeCount--;
      currentFireSize++;
    }
  }

  if (burningNow.length === 0) {
    fireActive = false;
    currentFireSize = 0;
  }
}

function finalizeFire() {
  if (currentFireType === "prescribed") fireSizesPrescribed.push(currentFireSize);
  else fireSizesLightning.push(currentFireSize);

  if (fireSizesPrescribed.length > fireMaxKeep) fireSizesPrescribed.splice(0, fireSizesPrescribed.length - fireMaxKeep);
  if (fireSizesLightning.length > fireMaxKeep) fireSizesLightning.splice(0, fireSizesLightning.length - fireMaxKeep);

  currentFireSize = 0;
}

function fireStep() {
  if (!fireActive) return;

  const nextBurning = [];

  for (const i of burningNow) {
    for (const j of neighbors(i)) {
      if (j >= 0 && grid[j] === 1 && insideBoundaryIndex(j)) {
        grid[j] = 2;
        nextBurning.push(j);
        treeCount--;
        currentFireSize++;
      }
    }
    grid[i] = 0; // burn out
  }

  burningNow = nextBurning;

  if (burningNow.length === 0) {
    fireActive = false;
    finalizeFire();
  }
}

/** ---------- DS model attempt (asynchronous) ---------- */
function attempt(p, f) {
  const i = (rng() * N) | 0;
  const s = grid[i];

  if (s === 0) {
    if (rng() < p) { grid[i] = 1; treeCount++; }
  } else if (s === 1) {
    if (!fireActive && rng() < f) {
      // lightning is NOT constrained by polygon/circle
      const x = i % W, y = (i / W) | 0;
      startFire([i], "lightning", x, y);
    }
  }
}

/** ---------- Prescribed fire: use polygon placement if available ---------- */
function sampleKFromArray(arr, k) {
  // returns up to k unique elements, uniformly by shuffle (O(n) partial)
  const a = arr.slice();
  // Fisher-Yates partial shuffle
  for (let i = a.length - 1; i > 0; i--) {
    const j = (rng() * (i + 1)) | 0;
    [a[i], a[j]] = [a[j], a[i]];
  }
  return a.slice(0, Math.min(k, a.length));
}

function seedsFromPolygonExact(k) {
  if (!polyIndices || polyIndices.length === 0) return { seeds: [], cx: (W/2)|0, cy: (H/2)|0 };

  // collect tree cells inside polygon now
  const treesInside = [];
  for (const idx of polyIndices) {
    if (grid[idx] === 1) treesInside.push(idx);
  }
  const seeds = sampleKFromArray(treesInside, k);

  // pick a "center" as centroid of vertices (for stats/overlay reference; boundary uses polygon anyway)
  let cx = 0, cy = 0;
  for (const v of polyFinal) { cx += v.x; cy += v.y; }
  cx = Math.round(cx / polyFinal.length);
  cy = Math.round(cy / polyFinal.length);

  return { seeds, cx, cy };
}

function seedsFromDiskNearRandomExact(k) {
  // fallback method (no polygon): choose random center + disk enlarge until enough trees
  const useBoundary = containOnEl.checked;
  const bR = +containREl.value;

  function diskCandidates(cx, cy, r) {
    const out = [];
    const r2 = r*r;
    for (let dy = -r; dy <= r; dy++) {
      for (let dx = -r; dx <= r; dx++) {
        if (dx*dx + dy*dy > r2) continue;
        const x = cx + dx, y = cy + dy;
        if (x < 0 || x >= W || y < 0 || y >= H) continue;
        out.push(y * W + x);
      }
    }
    for (let i = out.length - 1; i > 0; i--) {
      const j = (rng() * (i + 1)) | 0;
      [out[i], out[j]] = [out[j], out[i]];
    }
    return out;
  }

  let best = { cx: 0, cy: 0, seeds: [] };

  for (let tries = 0; tries < 18; tries++) {
    const cx = (rng() * W) | 0;
    const cy = (rng() * H) | 0;

    let r = Math.max(1, Math.ceil(Math.sqrt(k / Math.PI)));
    if (useBoundary) r = Math.min(r, bR);

    let found = [];

    for (let grow = 0; grow < 10; grow++) {
      const cand = diskCandidates(cx, cy, r);
      found = [];
      for (const idx of cand) {
        if (grid[idx] === 1) found.push(idx);
        if (found.length === k) break;
      }
      if (found.length === k) break;

      const nextR = Math.ceil(r * 1.35) + 1;
      r = useBoundary ? Math.min(nextR, bR) : Math.min(nextR, Math.floor(Math.max(W, H) / 2));
      if (useBoundary && r === bR) break;
    }

    if (found.length > best.seeds.length) best = { cx, cy, seeds: found };
    if (best.seeds.length === k) break;
  }

  return best;
}

igniteBtn.addEventListener("click", () => {
  if (fireActive) return;

  const k = +pfSizeEl.value;

  let cx = 0, cy = 0, seeds = [];

  // If user wants polygon and polygon exists, use it to place ignition
  if (usePolyEl.checked && polyFinal && polyMask && polyIndices) {
    const res = seedsFromPolygonExact(k);
    seeds = res.seeds; cx = res.cx; cy = res.cy;
  } else {
    const res = seedsFromDiskNearRandomExact(k);
    seeds = res.seeds; cx = res.cx; cy = res.cy;
  }

  startFire(seeds, "prescribed", cx, cy);

  renderSim();
  updateStatsUI();
  plotRho();
  plotFireSizes();
});

/** ---------- Plots (POINTS) ---------- */
function clearCanvas(ctx) {
  const w = ctx.canvas.width, h = ctx.canvas.height;
  ctx.save();
  ctx.setTransform(1,0,0,1,0,0);
  ctx.clearRect(0,0,w,h);
  ctx.fillStyle = "#fff";
  ctx.fillRect(0,0,w,h);
  ctx.restore();
}

function drawAxes(ctx, pad=34) {
  const w = ctx.canvas.width, h = ctx.canvas.height;
  ctx.strokeStyle = "#222";
  ctx.lineWidth = 1;
  ctx.beginPath();
  ctx.moveTo(pad, 10);
  ctx.lineTo(pad, h - pad);
  ctx.lineTo(w - 10, h - pad);
  ctx.stroke();
  return { w, h, pad };
}

function drawPoints(ctx, pts, color, radius=2) {
  ctx.fillStyle = color;
  for (const [x,y] of pts) {
    ctx.beginPath();
    ctx.arc(x, y, radius, 0, Math.PI*2);
    ctx.fill();
  }
}

function plotRho() {
  clearCanvas(rctx);
  const { w, h, pad } = drawAxes(rctx);
  if (rhoSeries.length < 2) return;

  const x0 = pad, x1 = w - 10;
  const y0 = h - pad, y1 = 10;

  const pts = [];
  const L = rhoSeries.length;
  for (let k = 0; k < L; k++) {
    const x = x0 + (k / (L - 1)) * (x1 - x0);
    const y = y0 - rhoSeries[k] * (y0 - y1);
    pts.push([x,y]);
  }

  drawPoints(rctx, pts, "#006", 1.6);

  rctx.fillStyle = "#111";
  rctx.font = "12px system-ui";
  rctx.fillText("ρ", 12, 18);
}

function makeLinearBins(maxSize, binCount) {
  const edges = [];
  for (let i = 0; i <= binCount; i++) edges.push(1 + (i / binCount) * (maxSize - 1));
  return edges;
}
function makeLogBins(maxSize) {
  const edges = [1];
  let e = 1;
  while (e < maxSize) {
    e = Math.ceil(e * 1.3 + 1);
    edges.push(Math.min(e, maxSize));
    if (edges[edges.length - 1] === maxSize) break;
  }
  return edges;
}

function binnedPoints(arr, edges) {
  if (arr.length === 0) return [];
  const counts = new Array(edges.length - 1).fill(0);
  for (const s of arr) {
    for (let b = 0; b < counts.length; b++) {
      const lo = edges[b], hi = edges[b+1];
      if (s >= lo && s <= hi) { counts[b]++; break; }
    }
  }
  const total = arr.length;
  const pts = [];
  for (let b = 0; b < counts.length; b++) {
    const p = counts[b] / total;
    if (p <= 0) continue;
    const mid = (edges[b] + edges[b+1]) / 2;
    pts.push([mid, p]);
  }
  return pts;
}

function plotFireSizes() {
  clearCanvas(fctx);
  const { w, h, pad } = drawAxes(fctx);

  const A = fireSizesLightning;
  const B = fireSizesPrescribed;
  if (A.length + B.length === 0) return;

  let maxSize = 1;
  for (const s of A) if (s > maxSize) maxSize = s;
  for (const s of B) if (s > maxSize) maxSize = s;

  const edges = logBinEl.checked ? makeLogBins(maxSize) : makeLinearBins(maxSize, 34);

  const ptsA = binnedPoints(A, edges);
  const ptsB = binnedPoints(B, edges);

  const allPts = ptsA.concat(ptsB);
  if (allPts.length < 2) return;

  const log10 = (v)=>Math.log10(v);
  let xmin = Infinity, xmax = -Infinity, ymin = Infinity, ymax = -Infinity;
  for (const [x,y] of allPts) {
    xmin = Math.min(xmin, x); xmax = Math.max(xmax, x);
    ymin = Math.min(ymin, y); ymax = Math.max(ymax, y);
  }

  const lx0 = log10(xmin), lx1 = log10(xmax);
  const ly0 = log10(ymin), ly1 = log10(ymax);

  const x0 = pad, x1 = w - 10;
  const y0 = h - pad, y1 = 10;

  function mapX(x){ return x0 + ((log10(x)-lx0)/(lx1-lx0 || 1))*(x1-x0); }
  function mapY(y){ return y0 - ((log10(y)-ly0)/(ly1-ly0 || 1))*(y0-y1); }

  // Labels
  fctx.fillStyle = "#111";
  fctx.font = "12px system-ui";
  fctx.fillText("P(size)", 8, 18);
  fctx.fillText("size", w - 44, h - 10);

  const scrA = ptsA.map(([x,y]) => [mapX(x), mapY(y)]);
  const scrB = ptsB.map(([x,y]) => [mapX(x), mapY(y)]);

  drawPoints(fctx, scrA, "#0a58ca", 2.2); // lightning (smaller)
  drawPoints(fctx, scrB, "#c92a2a", 3.2); // prescribed (larger)
}

/** ---------- Reset / Start / Loop ---------- */
function reset() {
  grid.fill(0);

  Ns = 0;
  treeCount = 0;
  fireCount = 0;

  fireActive = false;
  burningNow = [];
  currentFireSize = 0;
  currentFireType = "lightning";

  boundaryOn = false;
  boundaryMode = "none";

  rhoSeries.length = 0;
  fireSizesLightning.length = 0;
  fireSizesPrescribed.length = 0;

  rng = mulberry32(Number(seedEl.value) || 42);

  renderSim();
  updateStatsUI();
  plotRho();
  plotFireSizes();
}

resetBtn.addEventListener("click", reset);

startBtn.addEventListener("click", () => {
  running = !running;
  startBtn.textContent = running ? "Pause" : "Start";
});

logBinEl.addEventListener("change", plotFireSizes);

function tick() {
  if (running) {
    const p = +pEl.value;
    const f = +fEl.value;
    const spf = +spfEl.value;

    if (!fireActive) {
      for (let k = 0; k < spf; k++) { attempt(p, f); Ns++; }
    } else {
      const base = +fireSpfEl.value;
      const effective = animateEl.checked ? base : Math.max(base, 30);
      for (let k = 0; k < effective; k++) fireStep();
    }

    rhoSeries.push(treeCount / N);
    if (rhoSeries.length > rhoMaxPoints) rhoSeries.splice(0, rhoSeries.length - rhoMaxPoints);

    renderSim();
    updateStatsUI();
    plotRho();
    plotFireSizes();
  }
  requestAnimationFrame(tick);
}

reset();
requestAnimationFrame(tick);
</script>
</body>
</html>
